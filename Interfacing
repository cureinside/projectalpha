#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include "rplidar.h" //RPLIDAR standard sdk, all-in-one header


#ifndef _countof
#define _countof(_Array) (int)(sizeof(_Array) / sizeof(_Array[0]))
#endif

using namespace rp::standalone::rplidar;
using namespace std;

///////////////////////////////////////CHECK STATUS RPLIDAR///////////////////////////////////
bool checkRPLIDARHealth(RPlidarDriver * drv)
{
    u_result     op_result;
    rplidar_response_device_health_t healthinfo;


    op_result = drv->getHealth(healthinfo);
    if (IS_OK(op_result)) // the macro IS_OK is the preperred way to judge whether the operation is succeed.
	{ 
        //cout<<"RPLidar health status : %d"<<healthinfo.status<<endl; 
		printf("RPLidar health status : %d\n", healthinfo.status);
        if (healthinfo.status == RPLIDAR_STATUS_ERROR) 
		{
          fprintf(stderr, "Error, rplidar internal error detected. Please reboot the device to retry.\n");
          // enable the following code if you want rplidar to be reboot by software
          // drv->reset();
          return false;
         } else 
			{
            return true;
			}

    } 
	else 
	{
        fprintf(stderr, "Error, cannot retrieve the lidar health code: %x\n", op_result);
        return false;
    }
}
///////////////////////////////PROGRAM UTAMA//////////////////////////////////////////
int main(int argc, const char * argv[]) 
{
    const char * opt_com_path = NULL;
    _u32         opt_com_baudrate = 115200;
    u_result     op_result;

    // read serial port from the command line...
    if (argc>1) opt_com_path = argv[1]; // or set to a fixed value: e.g. "com3" 

    // read baud rate from the command line if specified...
    if (argc>2) opt_com_baudrate = strtoul(argv[2], NULL, 10);


    if (!opt_com_path) 
	{
		#ifdef _WIN32
        // use default com port
        opt_com_path = "\\\\.\\com3";
		#else
        opt_com_path = "/dev/ttyUSB0";
		#endif
    }

    // create the driver instance
    RPlidarDriver * drv = RPlidarDriver::CreateDriver(RPlidarDriver::DRIVER_TYPE_SERIALPORT);
    
    if (!drv) 
	{
        fprintf(stderr, "insufficent memory, exit\n");
        exit(-2);
    }


    // make connection...
    if (IS_FAIL(drv->connect(opt_com_path, opt_com_baudrate))) 
	{
        fprintf(stderr, "Error, cannot bind to the specified serial port %s.\n"
            , opt_com_path);
        goto on_finished;
    }



    // check health...
    if (!checkRPLIDARHealth(drv)) 
	{
        goto on_finished;
    }


    // start scan...
    drv->startScan();

    // fetech result and print it out...
	int random = 0;
	while (1) 
	{
        rplidar_response_measurement_node_t nodes[360*2];
        size_t   count = _countof(nodes);

        op_result = drv->grabScanData(nodes, count);

		//ambil data & scan data
        if (IS_OK(op_result)) 
		{
            drv->ascendScanData(nodes, count);
			
			ofstream arrayData("\\\\Robiyanto\\share-robiyanto\\datalidar.txt",ios::ate);
			arrayData.clear();
			char a[20]; random++; if (random==100) random = 0;
			//sprintf(a,"%d\n%d\n",random,count);
		sprintf_s(a,"%d\n",random);
			arrayData<<a;
//			arrayData.seekg(0,ios::beg); //abaikan
			//cout << count <<endl;
            for (int pos = 0; pos < (int)count ; ++pos) 
			{
				char msg[200];
				sprintf_s(msg,"%s%03.4f\t%08.2f\t%d\n", 
				(nodes[pos].sync_quality & RPLIDAR_RESP_MEASUREMENT_SYNCBIT) ?"":"", 
                (nodes[pos].angle_q6_checkbit >> RPLIDAR_RESP_MEASUREMENT_ANGLE_SHIFT)/64.0f,
                 nodes[pos].distance_q2/4.0f,
				 nodes[pos].sync_quality >> RPLIDAR_RESP_MEASUREMENT_QUALITY_SHIFT);
				arrayData<<msg;
				printf (msg);



            }
        }

    }

    // done!
	on_finished:
    RPlidarDriver::DisposeDriver(drv);
    return 0;
}
